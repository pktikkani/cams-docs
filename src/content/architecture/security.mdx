# Security Model

CAMS implements defense-in-depth with multiple security layers to prevent unauthorized access and credential abuse.

## Authentication

### Contractor Authentication
1. **Email/password login** with bcrypt-hashed passwords
2. **Device fingerprinting** â€” Unique device ID bound to contractor account
3. **Biometric unlock** â€” Fingerprint/Face ID for subsequent app opens
4. **JWT tokens** â€” Short-lived access tokens with refresh mechanism

### Guard Authentication
1. **Email/password login** with device fingerprint registration
2. **Site assignment** â€” Guards are bound to specific sites
3. **Session management** â€” Persistent token storage

### Admin Authentication
1. **Email/password login** with bcrypt-hashed passwords
2. **JWT in httpOnly cookies** â€” Prevents XSS token theft
3. **Role-based access control** â€” 4 roles with granular permissions

## TOTP (Time-based One-Time Password)

The core of CAMS security is the TOTP system:

| Parameter | Value |
|-----------|-------|
| Algorithm | HMAC-SHA256 |
| Period | 30 seconds |
| Digits | 6 |
| Seed | Per-contractor unique Base32-encoded secret |
| Standard | RFC 6238 / RFC 4226 |

### QR Code Payload Structure
```json
{
  "contractor_id": "uuid",
  "timestamp": 1700000000,
  "totp": "123456",
  "site_code": "SITE-001",
  "nonce": "unique-uuid",
  "device_fingerprint": "device-hash",
  "access_mode": "entry"
}
```

The payload is **Base64-encoded** before being rendered as a QR code.

## Device Security

### Root/Jailbreak Detection (Android)
- Checks 13+ common `su` binary paths
- Detects `test-keys` in build tags
- Scans for 15+ known root management apps (Magisk, SuperSU, etc.)
- **Kills process** immediately if root is detected

### Screenshot Prevention
- **Android**: `FLAG_SECURE` on all windows containing QR codes
- **iOS**: Screenshot detection via `UIApplication.userDidTakeScreenshotNotification`

### Encrypted Storage
- **Android**: `EncryptedSharedPreferences` with AES-256-GCM (MasterKey)
- **iOS**: Keychain Services with `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`

## Geofencing

Each site has configurable GPS coordinates and a geofence radius:

- Contractor app checks device location against site coordinates
- QR code generation is **blocked** when outside the geofence
- Distance to site boundary is displayed in real-time
- Guards can see geofence violations in scan results

### Geofence States
| State | Color | Description |
|-------|-------|-------------|
| Within Range | Green | Inside geofence, QR generation allowed |
| Outside Range | Red | Outside geofence, QR blocked |
| Permission Denied | Red | Location permission not granted |
| Acquiring GPS | Yellow | Waiting for location fix |
| No Geofence | Blue | Site has no geofence configured |

## Role-Based Access Control (Admin Portal)

| Role | Dashboard | Contractors | Sites | Schedules | Scanners | Logs | Settings |
|------|-----------|-------------|-------|-----------|----------|------|----------|
| Super Admin | âœ… | âœ… CRUD | âœ… CRUD | âœ… CRUD | âœ… CRUD | âœ… | âœ… |
| Site Admin | âœ… | âœ… CRUD | âœ… CRUD | âœ… CRUD | âœ… CRUD | âœ… | âŒ |
| Viewer | âœ… | ğŸ‘ï¸ Read | ğŸ‘ï¸ Read | ğŸ‘ï¸ Read | ğŸ‘ï¸ Read | âœ… | âŒ |
| Auditor | âœ… | âŒ | âŒ | âŒ | âŒ | âœ… | âŒ |

## HMAC-SHA256 Request Signing (Layer 7)

All mobile API requests are signed with HMAC-SHA256 to prevent tampering:

| Component | Detail |
|-----------|--------|
| Algorithm | HMAC-SHA256 |
| Signing data | `timestamp + "." + request_body` |
| Headers | `X-Signature` (hex-encoded HMAC), `X-Timestamp` (Unix seconds) |
| Key delivery | Returned in login response (`hmac_key` field) |
| Freshness | Timestamp must be within 5 minutes of server time |

The HMAC key is delivered per-session at login and stored in encrypted device storage (Keychain on iOS, EncryptedSharedPreferences on Android).

## Nonce Anti-Replay (Layer 3)

Each QR scan includes a unique nonce (UUID v4):

- Stored in **Redis** with a 5-minute TTL after first use
- Any repeated nonce is rejected as a replay attack
- Redis errors are tracked via Prometheus (`redis_errors_total`) and trigger critical alerts

## Network Security

- All API communication over **HTTPS/TLS**
- JWT tokens with expiration and refresh
- **httpOnly cookies** for admin portal (prevents XSS)
- Request authentication via `Authorization: Bearer <token>` header
- Input validation using Zod schemas on all endpoints

## Observability & Security Monitoring

The backend exposes Prometheus metrics and structured JSON logs for security monitoring:

| Metric | Type | Purpose |
|--------|------|---------|
| `auth_failures_total{type}` | Counter | Tracks invalid_credentials, invalid_token, missing_signature, hmac_mismatch, signature_expired, account_disabled |
| `scan_results_total{result,site_code}` | Counter | Tracks granted/denied scan outcomes per site |
| `redis_errors_total{operation}` | Counter | Tracks Redis failures (nonce_check, nonce_set) |

### Automated Alerts (Grafana)

| Alert | Trigger | Severity |
|-------|---------|----------|
| Auth failure spike | >10 failures in 5 min | Critical |
| HMAC rejection spike | >5 signature mismatches in 5 min | Critical |
| Redis errors | Any Redis error | Critical |
| High error rate | >5% 5xx responses for 5 min | Warning |
| High latency | P95 > 2s for 5 min | Warning |
| Scan denial anomaly | >80% denials in 15 min | Warning |
