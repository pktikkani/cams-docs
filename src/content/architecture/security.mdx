# Security Model

CAMS implements defense-in-depth with multiple security layers to prevent unauthorized access and credential abuse.

## Authentication

### Contractor Authentication
1. **Email/password login** with bcrypt-hashed passwords (cost factor 14)
2. **Device fingerprinting** ‚Äî SHA-256 hash format validated (64 hex chars), bound to contractor account
3. **Biometric unlock** ‚Äî Fingerprint/Face ID for subsequent app opens
4. **JWT tokens** ‚Äî Short-lived access tokens with `iss`, `sub`, `aud` claims and refresh mechanism

### Guard Authentication
1. **Email/password login** with SHA-256 device fingerprint validation
2. **Site assignment** ‚Äî Guards are bound to specific sites
3. **JWT tokens** ‚Äî 7-day expiry with Redis-based revocation on deactivation

### Admin Authentication
1. **Email/password login** with bcrypt-hashed passwords
2. **JWT in httpOnly cookies** ‚Äî Prevents XSS token theft
3. **Role-based access control** ‚Äî 4 roles with granular permissions

## TOTP (Time-based One-Time Password)

The core of CAMS security is the TOTP system:

| Parameter | Value |
|-----------|-------|
| Algorithm | HMAC-SHA256 |
| Period | 30 seconds |
| Digits | 6 |
| Seed | Per-contractor unique Base32-encoded secret |
| Standard | RFC 6238 / RFC 4226 |

### QR Code Payload Structure
```json
{
  "contractor_id": "uuid",
  "timestamp": 1700000000,
  "totp": "123456",
  "site_code": "SITE-001",
  "nonce": "unique-uuid",
  "device_fingerprint": "device-hash",
  "access_mode": "entry"
}
```

The payload is **Base64-encoded** before being rendered as a QR code.

## Device Security

### Root/Jailbreak Detection (Android)
- Checks 13+ common `su` binary paths
- Detects `test-keys` in build tags
- Scans for 15+ known root management apps (Magisk, SuperSU, etc.)
- **Kills process** immediately if root is detected

### Screenshot Prevention
- **Android**: `FLAG_SECURE` on all windows containing QR codes
- **iOS**: Screenshot detection via `UIApplication.userDidTakeScreenshotNotification`

### Encrypted Storage
- **Android**: `EncryptedSharedPreferences` with AES-256-GCM (MasterKey)
- **iOS**: Keychain Services with `kSecAttrAccessibleWhenUnlockedThisDeviceOnly`

## Geofencing

Each site has configurable GPS coordinates and a geofence radius:

- Contractor app checks device location against site coordinates
- QR code generation is **blocked** when outside the geofence
- Distance to site boundary is displayed in real-time
- Guards can see geofence violations in scan results

### Geofence States
| State | Color | Description |
|-------|-------|-------------|
| Within Range | Green | Inside geofence, QR generation allowed |
| Outside Range | Red | Outside geofence, QR blocked |
| Permission Denied | Red | Location permission not granted |
| Acquiring GPS | Yellow | Waiting for location fix |
| No Geofence | Blue | Site has no geofence configured |

## Role-Based Access Control (Admin Portal)

| Role | Dashboard | Contractors | Sites | Schedules | Scanners | Logs | Settings |
|------|-----------|-------------|-------|-----------|----------|------|----------|
| Super Admin | ‚úÖ | ‚úÖ CRUD | ‚úÖ CRUD | ‚úÖ CRUD | ‚úÖ CRUD | ‚úÖ | ‚úÖ |
| Site Admin | ‚úÖ | ‚úÖ CRUD | ‚úÖ CRUD | ‚úÖ CRUD | ‚úÖ CRUD | ‚úÖ | ‚ùå |
| Viewer | ‚úÖ | üëÅÔ∏è Read | üëÅÔ∏è Read | üëÅÔ∏è Read | üëÅÔ∏è Read | ‚úÖ | ‚ùå |
| Auditor | ‚úÖ | ‚ùå | ‚ùå | ‚ùå | ‚ùå | ‚úÖ | ‚ùå |

## HMAC-SHA256 Request Signing (Layer 7)

All mobile API requests are signed with HMAC-SHA256 to prevent tampering:

| Component | Detail |
|-----------|--------|
| Algorithm | HMAC-SHA256 |
| Signing data | `timestamp + "." + request_body` |
| Headers | `X-Signature` (hex-encoded HMAC), `X-Timestamp` (Unix seconds) |
| Key delivery | **Per-device 256-bit key** generated on login, stored in `devices.hmac_key` / `scanner_devices.hmac_key` |
| Key resolution | Middleware resolves the device's HMAC key from JWT identity |
| Freshness | Timestamp must be within 5 minutes of server time |

Each device receives a unique HMAC key on login. The backend resolves the correct key from the JWT identity, eliminating the need for a shared secret. Keys are stored in encrypted device storage (Keychain on iOS, EncryptedSharedPreferences on Android).

## JWT Token Security

All JWTs include standardized claims to prevent token type confusion:

| Claim | Value | Purpose |
|-------|-------|---------|
| `iss` | `cams-api` | Issuer ‚Äî rejects tokens from other services |
| `sub` | User/device UUID | Subject ‚Äî identifies the authenticated entity |
| `aud` | `contractor`, `scanner`, or `admin` | Audience ‚Äî prevents using admin tokens on scanner endpoints (and vice versa) |

Each middleware validates both `iss` and `aud` on every request. A contractor token cannot access admin endpoints, even if the JWT signature is valid.

## Nonce Anti-Replay (Layer 3)

Each QR scan includes a unique nonce (UUID v4):

- Stored in **Redis** with a 5-minute TTL after first use
- Any repeated nonce is rejected as a replay attack
- **Fail-closed** ‚Äî Redis errors return HTTP 503 (never silently allow through)
- Redis errors are tracked via Prometheus (`redis_errors_total`) and trigger critical alerts

## Network Security

- All API communication over **HTTPS/TLS**
- JWT tokens with expiration, refresh, and `iss`/`sub`/`aud` claim validation
- **httpOnly cookies** for admin portal (prevents XSS)
- Request authentication via `Authorization: Bearer <token>` header
- **CORS origin restriction** ‚Äî Configurable via `CORS_ORIGINS` env var (no more wildcard)
- Input validation using Zod schemas on admin portal, Go validation on backend

## Input Validation (Backend)

The backend validates all inputs at the API boundary:

| Validation | Where | Detail |
|------------|-------|--------|
| UUID format | All path parameters (12 handlers) | `uuid.Parse()` ‚Äî returns 400 on invalid |
| Date format | `dateFrom`/`dateTo` query params | Must match `YYYY-MM-DD` ‚Äî returns 400 on invalid |
| Time format | Schedule `start_time`/`end_time` | Must match `HH:MM` or `HH:MM:SS` ‚Äî returns 400 on invalid |
| Device fingerprint | Login endpoints | Must be 64 hex chars (SHA-256) ‚Äî returns 400 on invalid |
| Email/password | Admin login | Must be non-empty ‚Äî returns 400 `missing_fields` |
| Batch size | Bulk import contractors | Max 100 rows per request |
| Batch size | Bulk create schedules | Max 500 combinations per request |
| Batch size | Offline scan sync | Max 500 scans per request |
| Photo size | Photo upload | Max 2MB base64 |
| Export limits | Export endpoints | Max 10,000 rows per export |

## Observability & Security Monitoring

The backend exposes Prometheus metrics and structured JSON logs for security monitoring:

| Metric | Type | Purpose |
|--------|------|---------|
| `auth_failures_total{type}` | Counter | Tracks invalid_credentials, invalid_token, missing_signature, hmac_mismatch, signature_expired, account_disabled |
| `scan_results_total{result,site_code}` | Counter | Tracks granted/denied scan outcomes per site |
| `redis_errors_total{operation}` | Counter | Tracks Redis failures (nonce_check, nonce_set) |

### Automated Alerts (Grafana)

| Alert | Trigger | Severity |
|-------|---------|----------|
| Auth failure spike | >10 failures in 5 min | Critical |
| HMAC rejection spike | >5 signature mismatches in 5 min | Critical |
| Redis errors | Any Redis error | Critical |
| High error rate | >5% 5xx responses for 5 min | Warning |
| High latency | P95 > 2s for 5 min | Warning |
| Scan denial anomaly | >80% denials in 15 min | Warning |
